# 多任务系统

在大一搓单片机时我就有一个愿望：能够造出来一个能够多任务切换的系统，让一个单片机同时（时分复用地）处理多任务。这并不依赖于特权级机制，也是作为一个操作系统的基础。因此本书将它置于第二章。

本章将实现一个分时多任务系统，实现：
- 任务的 spawn, yield 和 exit
- 定时器和抢占式调度

本章节尽力避免了特权级机制和系统调用相关知识，这些都留在下一章探究。

当然，本章也没有使用 Rust 自带的异步逃课，一来我们还没有实现动态内存分配，没法很优雅地管理 tasks，更不支持递归的异步函数；二来这玩意基于状态机，且共享栈空间需要返回到根函数，比起基于 sp 和 ra 寄存器的纯函数调用开销还是大了亿点；最重要的是，失去了体会危险而优雅的上下文切换机制的机会。

## 项目组织

本章开始会分 crate 做项目。本章节分两个 crate：一个是入口 crate `os`，位于根目录；一个是内核 crate `kernel`，位于 `kernel/` 目录下。

本章文件组织大致如下（此为“任务切换”节的代码结构）：

```txt
.
├── Cargo.lock
├── Cargo.toml
├── kernel
│   ├── Cargo.toml
│   └── src
│       ├── console.rs
│       ├── lib.rs
│       ├── logging.rs
│       ├── machine.rs
│       └── task
│           ├── mod.rs
│           └── switch.s
└── src
    ├── entry.s
    ├── link-qemu.ld
    ├── main.rs
    └── tasks.rs
```

